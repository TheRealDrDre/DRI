---
title: "DRI_analysis"
author: "pjrice"
date: "January 26, 2017"
output: html_document
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

############################################################################################################################################################################
############################################################################################################################################################################
############################################################################################################################################################################
############################################################################################################################################################################
############################################################################################################################################################################

Keep all the junk above for right now to reference while writing document

First, we should probably set the working directory and load the data, right?

```{r load da data}
#set wd to data dir
setwd('/media/storage/testing_ground/R/RR_TMS_data')

#read data file
data = read.table('table4R.txt', header=T, sep=",")
```

We did it reddit!!!!

Now convert some of the values to make the table slightly more readable...

```{r clarify}

#Convert some values to make it more readable
data$infIns[data$infIns == 0] = "Inferred"
data$infIns[data$infIns == 1] = "Instructed"

data$SF[data$SF == 0] = "Symbol"
data$SF[data$SF == 1] = "Finger"

data$PV[data$PV == 0] = "PMd" 
data$PV[data$PV == 1] = "Vertex"

data$ELN[data$ELN == 0] = "Early" 
data$ELN[data$ELN == 1] = "Late"
data$ELN[data$ELN == 2] = "noStim"

#convert subject IDs to factor
data$subjID = as.factor(data$subjID)

#replace "NaN"s with NA
data[data == 'NaN'] = NA

#add condition index column to data frame
data$condIdx = interaction(data$SF,data$PV,data$ELN,data$infIns)

```

Here's the head of our table:

```{r}

head(data)

```

Wow that's fuck ugly! Let's try again:

```{r kable}

library(knitr)

kable(head(data))

```

Wowee that's an alright looking table!

Let's continue actually working:

There are some NaNs in the dataset:
Subject 2406, block 1 is invalid - coil had drifted off target. All entries from that block have been NaNed, so let's not consider those.
There are also a couple of random NaNs in other subject's rule/stimRT vectors, where they did not respond - let's not consider these either.

While we're at it, let's make a subset of correct trials and a subset of incorrect trials to examine independently.

```{r NaNs}

#remove subj 2406 first block (NaNed out) and other random trials where subj didn't respond
data = subset(data, data$PV!="NaN" & data$ruleRT!="NaN" & data$stimRT!="NaN")

#get subset of only correct trials
correct = subset(data, data$success==1)

#get subset of only error trials
incorrect = subset(data, data$success!=1)

```

Cool. Let's now aggregate some data for success rates, rule RTs, and stim RTs:

```{r aggregate}

#aggregate success rate data
success = aggregate(data[c("success")], list(subjID=data$subjID,
                                             SF=data$SF,
                                             PV=data$PV,
                                             ELN=data$ELN,
                                             infIns=data$infIns),
                    mean)

#aggregate ruleRT data
ruleRT = aggregate(data[c("ruleRT")], list(subjID=data$subjID,
                                             SF=data$SF,
                                             PV=data$PV,
                                             ELN=data$ELN,
                                             infIns=data$infIns),
                    mean)

#aggregate stimRT data
stimRT = aggregate(data[c("stimRT")], list(subjID=data$subjID,
                                             SF=data$SF,
                                             PV=data$PV,
                                             ELN=data$ELN,
                                             infIns=data$infIns),
                    mean)

kable(head(success))
kable(head(ruleRT))
kable(head(stimRT))
```

Alrighty, that's nice. How about we start plotting some data?

Let's plot global ruleRT:stimRT scatterplots first

```{r scatterplots}

library(ggplot2)

#scatterplots - color by trial cond - successes and errors
  #global ruleRT:stimRT for all conditions
  #per subject ruleRT:stimRT for all conditions
  #same as the two above, for single conditions and joint conditions

#global ruleRT:stimRT
#create the plot, considering only correct trials, with stimRT on xaxis and ruleRT on yaxis
sp1 = ggplot(correct, aes(x=stimRT, y=ruleRT))
#color the points by subjID and print the plot
(sp1+geom_point(aes(color=subjID))
    +labs(title='The relationship between ruleRT and stimRT, correct trials only',x = 'stimRT (s)', y = 'ruleRT (s)')
    +scale_x_continuous(breaks = round(seq(0,round(max(data$stimRT))+1,by = 0.2),1))
    +scale_y_continuous(breaks = round(seq(0,round(max(data$ruleRT))+1,by = 0.2),1)))

#create the plot, considering only error trials, with stimRT on xaxis and ruleRT on yaxis
sp2 = ggplot(incorrect, aes(x=stimRT, y=ruleRT))
#color the points by subjID and print the plot
(sp2+geom_point(aes(color=subjID))
  +labs(title='The relationship between ruleRT and stimRT, incorrect trials only',x = 'stimRT (s)', y = 'ruleRT (s)')
  +scale_x_continuous(breaks = round(seq(0,round(max(data$stimRT))+1,by = 0.2),1))
  +scale_y_continuous(breaks = round(seq(0,round(max(data$ruleRT))+1,by = 0.2),1)))


```

What do the ruleRT:stimRT plots look like per subject?

```{r subjscatterplots}
library(gridExtra)
#per subject ruleRT:stimRT, correct trials - color by trial condition
#currently plots all subjects

#get unique subjIDs
subjIDs = as.numeric(levels(data$subjID))
#make empty list to put plots into
subjPlots = list()
for (i in 1:length(subjIDs)){
  
  #get subject subsets
  subjSubset = subset(correct, correct$subjID==subjIDs[i])
  #make plots
  subjPlots[[i]] = (ggplot(subjSubset, aes(x=stimRT, y=ruleRT))
                    +geom_point(aes(color=condIdx))
                    +theme(legend.position='none')
                    +scale_x_continuous(breaks = round(seq(0,5,by = 0.2),1))
                    +scale_y_continuous(breaks = round(seq(0,5,by = 0.5),1))
                    +labs(title=paste('Subject',toString(subjIDs[i])),x = 'stimRT (s)', y = 'ruleRT (s)'))
}

#plot all 8
do.call("grid.arrange", c(subjPlots,ncol=2))

```

What do the ruleRT:stimRT plots look like per condition?

```{r condscatterplots}
#global scatterplot for the different conditions
conds = levels(correct$condIdx)
condPlots = list()

for (i in 1:length(levels(correct$condIdx))){
  
  #get cond subset
  condSubset = subset(correct, correct$condIdx==conds[i])
  #make plots
  condPlots[[i]] = (ggplot(condSubset, aes(x=stimRT, y=ruleRT))
                    +geom_point(aes(color=subjID))
                    +theme(legend.position='none')
                    +scale_x_continuous(breaks = seq(0,5,by = 0.2))
                    +scale_y_continuous(breaks = seq(0,5,by = 0.2))
                    +labs(title=paste('Condition',conds[i]),x = 'stimRT (s)', y = 'ruleRT (s)'))
  
}

# plot all
do.call("grid.arrange", c(condPlots,ncol=4))

```

How about some histograms with density estimates overlaid?

```{r histograms}
#histogram/density plots

#global ruleRT hist w/ density
hp1 = ggplot(correct, aes(x=ruleRT))
(hp1+geom_histogram(binwidth = 0.1, aes(y = ..density..))
    +geom_density()
    +labs(title='ruleRTs',x = 'ruleRT (s)'))

#global stimRT hist w/ density
hp1 = ggplot(correct, aes(x=stimRT))
(hp1+geom_histogram(binwidth = 0.1, aes(y = ..density..))
  +geom_density()
  +labs(title='stimRTs',x = 'stimRT (s)'))

#plot all subject stimRT density estimates on top of one another
ggplot(correct, aes(stimRT, fill = subjID)) +geom_density(alpha = 0.2)

#plot all condition stimRT density estimates on top of one another
ggplot(correct, aes(stimRT, fill = condIdx)) +geom_density(alpha = 0.2)+theme(legend.position='bottom')

```

Because there are so many conditions, it's a little difficult to see what's going on. But, it seems as if there are at least 3 peaks. Let's try to justify dropping some conditions and checking out what the resultant graphs look like.

First, let's compare all vertex stimulation trials to all no stimulation (both PMd and Vertex), to see if we can justify saying that being stimulated over Vertex was like not being stimulated at all:

```{r ANOVA1}
#ns v. Vs

dCT1 = subset(correct, correct$PV=='Vertex' | (correct$PV=='PMd' & correct$ELN=='noStim'))

dCT1$ELN[dCT1$ELN == 'Early'] = "Stim"
dCT1$ELN[dCT1$ELN == 'Late'] = "Stim"

dControlTest1.1 = aggregate(dCT1[c('stimRT')], by=list(subjID = dCT1$subjID,
                                                       nsVs = dCT1$ELN),
                            FUN=mean)
summary(aov(stimRT ~ (nsVs) + Error(subjID), dControlTest1.1))


```

So, it seems as though being stimulated over Vertex is the same as not being stimulated at all.

Second, let's compare all vertex trials to only PMd nostim trials, to see if we can justify saying that being stimulated over Vertex was like not being stimulated over PMd:
```{r ANOVA2}

#get subset of all vertex trials and PMd nostim trials 
dCT2 = subset(correct, correct$PV=='Vertex' | (correct$PV=='PMd' & correct$ELN=='noStim'))

#get the means of the different conditions
dControlTest2.1 = aggregate(dCT2[c('stimRT')], by=list(subjID = dCT2$subjID, 
                                                       SF = dCT2$SF, 
                                                       PV = dCT2$PV, 
                                                       ELN = dCT2$ELN, 
                                                       infIns = dCT2$infIns), 
                            FUN=mean)

#run the ANOVA
#removed ELN from the error term here because I was getting a warning that the "Error() model is singular" - 
#ELN only has one level for PMd trials in this case, while it has 3 for Vertex trials
summary(aov(stimRT ~ (ELN * SF * PV * infIns) + Error(subjID/(SF * PV * infIns)), dControlTest2.1))

#this one comes out "looking better"
summary(aov(stimRT ~ (ELN * SF * PV * infIns) + Error(subjID), dControlTest2.1))

#try collapsing across SF, infIns just to see
dControlTest2.2 = aggregate(dCT2[c('stimRT')], by=list(subjID = dCT2$subjID, 
                                                       PV = dCT2$PV, 
                                                       ELN = dCT2$ELN), 
                            FUN=mean)
#no interaction because ELN is only one level for PMd in this case
summary(aov(stimRT ~ (PV * ELN) + Error(subjID/PV), dControlTest2.2))

summary(aov(stimRT ~ (PV * ELN) + Error(subjID), dControlTest2.2))

#collapse across ELN too for funsicals
dControlTest2.3 = aggregate(dCT2[c('stimRT')], by=list(subjID = dCT2$subjID, 
                                                       PV = dCT2$PV), 
                            FUN=mean)

summary(aov(stimRT ~ (PV) + Error(subjID/PV), dControlTest2.3))

#the same as the one above
summary(aov(stimRT ~ (PV) + Error(subjID), dControlTest2.3))


```

Well ain't that a fine howdy-do. We see that in the subset of all vertex trials and only PMd nostim trials, Sym/Fin and Inf/Ins are different, but E/L/N are not, and of special importance, P/V are not - so, participants behave similarly when stimulated over Vertex and when not stimulated over PMd.













