;;;; =================================================================
;;;; DRI
;;;; -----------------------------------------------------------------
;;;; An ACT-R model for the DRI experiment by Patrick J. Rice.
;;;; -----------------------------------------------------------------
;;;; General idea is to have different models
;;;; 
;;;; Implementing TMS:
;;;; TMS is implemented by adding 500ms to the execution time
;;;; of any production that could be targeted. Productions encode
;;;; control, so the assumption is legit.
;;;; (Potentially, all of the prods could be tested!!!).
;;;;
;;;; to do:
;;;; Add a DM phase, in which the model decides whether it is the case
;;;; to respond or to invert.
;;;; ------------------------------------------------------------------

(clear-all)
(define-model dri

(sgp :auto-attend t
     :esc nil)

(chunk-type parity-fact number parity)

(chunk-type (dri-object (:include visual-object))
	    kind location)

(chunk-type wm rule action kind even odd left right)

(chunk-type trial step)

(chunk-type pair target alternative) 

(add-dm (even isa chunk) (odd isa chunk)
	(a isa chunk) (b isa chunk)
	(processing isa chunk) (respond isa chunk)
	(done isa chunk)

	;; Basic structures
	(stimulus isa chunk)
	(rule isa chunk)
	(screen isa chunk)
	(pause isa chunk)
	(option isa chunk)
	(target isa chunk)
	(action isa chunk)
	(instructions isa chunk)
	(can-proceed isa chunk)
	(mist-infer isa chunk)

	;; Parity
	(one-odd isa parity-fact
		 number 1 parity odd)
	(two-even isa parity-fact
		 number 2 parity even)
	(three-odd isa parity-fact
		 number 3 parity odd)
	(four-even isa parity-fact
		 number 4 parity even)
	(five-odd isa parity-fact
		 number 5 parity odd)
	(six-even isa parity-fact
		 number 6 parity even)
	(seven-odd isa parity-fact
		   number 7 parity odd)
	(eight-even isa parity-fact
		    number 8 parity even)
	(nine-odd isa parity-fact
		  number 9 parity odd)

	;;; Alternatives
	(index-middle isa pair
		      target index
		      alternative middle)

	(middle-index isa pair
		      target middle
		      alternative index)

	(a-b isa pair
	     target a
	     alternative b)

	(b-a isa pair
	     target b
	     alternative a)
		  
	)

;;; VISUAL PROCESSING

(p look-at-screen
   "Looks at the screen if nothing to process" 
   ?visual>
     state free
     buffer empty
   ?visual-location>
     state free
     buffer empty
==>
   +visual-location>
     kind screen
)

(p recover-from-visual-change
   "If the visual scene changes abrubtly, re-encode the screen"
   ?visual>
     error t
==>
   +visual-location>
     kind screen
)

;;; RULE ENCODING PHASE

(p look-at-rule
   ?visual>
   - state error
     state free

   =visual>
     kind screen
     value rule
==>
   +visual-location>
     kind rule
)

(p encode-rule
   ?visual>
     state free
   ?imaginal>
     state free
     buffer empty
   =visual>
     kind rule
     value =RULE
==>
  +imaginal>
     isa wm
     kind instructions
     rule =RULE

  +goal>
     isa trial
     step processing
     
  =visual>
)

(p look-at-action
   ?visual>
     state free

   ?imaginal>
     state free
     
   =visual>
     kind rule

   =imaginal>
   - rule nil
     action nil
==>
   =imaginal>     
   +visual-location>
     kind action  
)


(p encode-action
   ?visual>
     state free

   ?imaginal>
     state free

   =visual>
     kind action
     value =ACTION
    
   =imaginal>
   - rule nil
     action nil
==>
  =visual>

  *imaginal>
     isa wm
     action =ACTION
     )


(p retrieve-alternative
   ?visual>
     state free

   ?imaginal>
     state free

   ?retrieval>
     state free
     buffer empty
     
   =visual>
     kind action
     value =ACTION
    
   =imaginal>
   - rule nil
     action =ACT
==>
     
   +retrieval>
     isa pair
     target =ACT
   =imaginal>
   =visual>  
)


(p encode-alternative
   ?visual>
     state free

   ?imaginal>
     state free

   =retrieval>
     state free
     buffer empty
     
   =imaginal>
   - rule nil
   action =ACT
   
   =retrieval>
     isa pair
     target =ACT
     alternative =ALT
==>
   *imaginal>
     alternative =ALT
)

(p move-on
   =imaginal>
   - rule nil
   - action nil

   =visual>
     kind action
   
   ?imaginal>
     state free

   ?manual>
     preparation free
     processor free
     execution free

==>
   =imaginal>
   +manual>
     isa punch
     hand right
     finger index
)

;;; ------------------------------------------------------------------
;;; PREPARATION PHASE
;;; ------------------------------------------------------------------
;;; During the preparation phase, the commands are prepared.
;;; ------------------------------------------------------------------

(p prepare-finger-1
   "Prepares a response for the finger condition, ODD/INDEX mappings"
   =imaginal>
     kind instructions
     action index
     rule odd
     odd nil
     even nil
   ?imaginal>
     state free  
 ==>
   *imaginal>
     odd index
     even middle
)

(p prepare-finger-2
   "Prepares a response for the finger condition, ODD/MIDDLE mappings"
   =imaginal>
     kind instructions
     action middle
     rule odd
     odd nil
     even nil
   ?imaginal>
     state free  
 ==>
   *imaginal>
     odd middle
     even index
)

(p prepare-finger-3
   "Prepares a response for the finger condition, EVEN/INDEX mappings"
   =imaginal>
     kind instructions
     action index
     rule even
     odd nil
     even nil
 ==>
   *imaginal>
     odd middle
     even index
)

(p prepare-finger-4
   "Prepares a response for the finger condition, EVEN/MIDDLE mappings"
   =imaginal>
     kind instructions
     action middle
     rule even
     odd nil
     even nil
   ?imaginal>
     state free  
 ==>
   *imaginal>
     odd index
     even middle
)


(p prepare-symbol
   "Prepares to respond to symbols"
   =imaginal>
     kind instructions
   - action nil
   - rule nil
     left nil
     right nil

   ?imaginal>
     state free
==>
   *imaginal>
     left index
     right middle
)     

;;; ------------------------------------------------------------------
;;; TARGET PROCESSING
;;; ------------------------------------------------------------------
;;; During target processing, we first establish the parity of a
;;; target. If the parity is consistent with what expected, we proceed
;;; with the prepared command. If not, we need to re-prepare the
;;; motor command.
;;; ------------------------------------------------------------------

(p look-at-target
   ?visual>
     state free

   =visual>
     value stimulus
==>
   +visual-location>
     kind target
)


(p retrieve-parity
   ?visual>
     state free

   =imaginal>
     kind instructions
   - rule nil
     
   ?retrieval>
     state free
     buffer empty
   
   =visual>
     kind target
     value =NUM

==>
  =visual>
  =imaginal>
  +retrieval>
    isa parity-fact
    number =NUM
)

;;; ------------------------------------------------------------------
;;; TARGET PROCESSING
;;; ------------------------------------------------------------------
;;; Reprepares the imaginal buffer if parity does not match
;;; ------------------------------------------------------------------

(p parity-verified
   =imaginal>
     rule =PARITY

   =goal>
     step processing
   
   =visual>
     kind target
     
   =retrieval>
     isa parity-fact
     parity =PARITY
==>
   =goal>
     step respond
)

(p parity-not-verified
   =imaginal>
     rule =PARITY
     action =ACT
     alternative =OTHER

   =goal>
     step processing
   
   =visual>
     kind target
     
   =retrieval>
     isa parity-fact
   - parity =PARITY
==>
   =imaginal>
     action =OTHER
   =goal>
     step respond  
)

;;; ------------------------------------------------------------------
;;; RESPONSE
;;; ------------------------------------------------------------------
;;; In this model, the responses have to be prepared before hand in
;;; the imaginal buffer
;;; ------------------------------------------------------------------

;;; RESPONSE for FINGER CONDITION

(p respond-finger
   =visual>
     kind target
     value =NUM
     
   =retrieval>
     isa parity-fact
     number =NUM
     parity =RULE

   =imaginal>
     =RULE =FINGER

   ?manual>
     preparation free
     processor free
     execution free
==>
   +manual>
     isa punch
     hand right
     finger =FINGER
)
 

;;; RESPONSE FOR SYMBOLS

(p find-instructed-symbol
   =imaginal>
     action =SYMBOL
   - action index
   - action middle  

   =visual>
     kind target
     
   ?retrieval>
     buffer full
    
   ?visual>
     state free
==>
   =imaginal>
   +visual-location>
     kind option
     value =SYMBOL
)

(p decide-instructed-symbol
   =imaginal>
     rule =PARITY

   =goal>
     step processing
   
   =visual>
     kind option
     
   =retrieval>
     isa parity-fact
     parity =PARITY

   ?visual>
     state free
==>
   *goal>     
     step respond
   =visual>
)

(p decide-inferred-symbol
   =imaginal>
     rule =PARITY

   =goal>
     step processing
   
   =visual>
     kind option
     value =OPTION
     
   =retrieval>
     isa parity-fact
   - parity =PARITY

   ?visual>
     state free
==>
   +visual-location>
     kind option
   - value =OPTION
    
   *goal>     
     step respond

)

(p respond-symbol-left
   =goal>
     step respond

   =visual>
     kind option
     location left
     
   ?manual>
     preparation free
     processor free
     execution free

==>
  +manual>
     isa punch
     hand right
     finger index
)


(p respond-symbol-right
   =goal>
     step respond

   =visual>
     kind option
     location right
     
   ?manual>
     preparation free
     processor free
     execution free

==>
  +manual>
     isa punch
     hand right
     finger middle
)


;;; DONE

(p done
   ?visual>
   - state error
     state free

   =visual>
     kind screen
     value done
==>
   !stop!
)

) ;; end of model
